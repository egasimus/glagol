(let [emitter
        (new (.-EventEmitter2 (require "eventemitter2"))
          { :maxListeners 64 :wildcard true } )

      api
        @client-api

      update
        (fn [k v] (client-state.value.set (assoc @client-state k v)))

      replace
        (fn [array target new-value]
          (array.map (fn [old-value index]
            (if (= index target) new-value old-value))))]

  ;; sequencer gui
  (emitter.on "sequencer.click" (fn [t n]
    (let [curr-track
            (aget @client-state t)
          curr-val
            (aget curr-track n)
          next-val
            (- 1 curr-val)
          next-track
            (.concat (.concat (curr-track.slice 0 n) next-val)
              (curr-track.slice (+ 1 n)))]
      (console.log (assoc @client-state t next-track))
      (client-state.value.set (assoc @client-state t next-track)))))

  ;; react to transport events
  (emitter.on "transport.play" (fn []
    (log "play!")
    (.then (api.invoke "start") (fn [] (log "playing.")))))
  (emitter.on "transport.pulse" (fn [t] (update :position t)))

  ;; respond to midi control
  (let [on-fader
          (fn [_ _ track-num selector]
            (let [state   @client-state
                  track   (aget state.tracks track-num)
                  data    (assoc track.data
                            :selector (/ selector 127)
                            :selected (Math.floor (/ selector 16)))
                  tracks  (replace state.tracks track-num
                            (assoc track :data data))]
              (update :tracks tracks)))
        on-knob
          (fn [t m1 m2 m3]
            (log "knob" (- m2 16)))]
    (emitter.on "control.nano" (fn [msg]
      (let [t  (aget msg 0)
            m1 (aget msg 1)
            m2 (aget msg 2)
            m3 (aget msg 3)]
        (if (= m1 189)
          ((cond
            (< m2 8)                  on-fader
            (and (> m2 15) (< m2 24)) on-knob
            ) t m1 m2 m3))))))

  emitter)
