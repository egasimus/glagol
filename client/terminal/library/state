(let [state { :input    ""
              :focus    :input
              :results  []
              :selected -1 }]

  (../events/on :keytyped (fn [c]
    (set! state.input (state.input.concat c))
    (../render)))

  (../events/on :backspace (fn []
    (set! state.input (state.input.slice 0 -1))
    (set! state.focus :input)
    (../render)))

  (../events/on :search (fn []
    (.then (../api :invoke "library/search" state.input)
      (fn [results]
        (set! state.results  (JSON.parse results))
        (set! state.focus    :results)
        (set! state.selected 0)
        (../render))
      (fn [err]
        (log.as :err err)))))

  (../events/on :next-result (fn []
    (set! state.selected
      (if (< state.selected (- state.results.length 1))
        (+ state.selected 1)
        0))
    (../render)))

  (../events/on :prev-result (fn []
    (set! state.selected
      (if (> state.selected 0)
        (- state.selected 1)
        (- state.results.length 1)))
    (../render)))

  (../events/on :preview (fn []
    (../api :invoke "library/preview"
      (.-fullpath (aget state.results state.selected)))))

  state)
