(fn parse-template [el]

  (if (not (vector? el))
    (throw (Error. (str "element " el " must be an array"))))
  (if (not (string? (aget el 0)))
    (throw (Error. (str "first item of element array " el " is not a string"))))

  (let [parsed { :widget (aget el 0) :options {} :children [] }
        arg1   (aget el 1)
        args   (el.slice 2)
        args   (cond (string? args) [args]
                     (string? (aget args 0)) [args]
                     :else args)]

    (cond
      (string? arg1)
        (set! parsed.content arg1)

      (object? arg1) (do
        (set! parsed.options arg1)
        (cond
          (string? args)
            (set! parsed.content args)
          (vector? args)
            (set! parsed.children (args.map parse-template))
          :else
            (throw (Error. (str "children must be strings or element arrays")))))

      (vector? arg1)
        (set! parsed.children (if (string? (aget arg 1))
          [(parse-template arg1)] (arg1.map parse-template)))

      (not arg1) (do)

      :else
        (throw (Error. "unexpeced type of arg1 in element array")))

    parsed))
