(fn change [parsed new-parsed]
  (let [diff
          (.filter (or ((require "deep-diff") parsed new-parsed) [])
            (fn [d] (not (= (aget d.path (- d.path.length 1)) :rendered))))]

    (if (> diff.length 0) (log diff.length :changes))

    (diff.map (fn [d]
      (log d.kind (d.path.join "."))
      (cond

        (= d.kind :D)
        (if (and d.lhs.rendered d.lhs.rendered.parent)
          (d.lhs.rendered.parent.remove d.lhs.rendered))

        (= d.kind :E)
        (loop [path  d.path
               left  parsed
               right new-parsed]
          (cond
            (= (aget path 0) :children)
              (recur
                (path.slice 2)
                (aget left.children  (aget path 1))
                (aget right.children (aget path 1)))

            (< -1 (.index-of [:widget :options] (aget path 0)))
              (do
                (if (and left.rendered left.rendered.parent)
                  (let [parent left.rendered.parent
                        new-rendered (./render right)]
                    (parent.insertBefore new-rendered left.rendered)
                    (parent.remove left.rendered)
                    ))
                (log.as (aget path 0) "changed"))

            ;(= (aget path 0) :rendered)
              ;(let [new-rendered (./render node)]
                ;(log (keys node.rendered) new-rendered.parent)
                ;;(log.as node.widget (keys node) (keys node.rendered.parent))
                ;(node.rendered.parent.insert-before new-rendered node.rendered)
                ;;(node.rendered.parent.remove node-rendered)
                ;(set! node.rendered new-rendered))

            :else
              (throw (Error. (str
                "unknown fragment in diff path \"" (path.join ".") "\":"
                " \"" (aget path 0) "\""))))))))))
