(let [split-children (fn [children]
        (let [re1 (RegExp. "(\\d+x\\d+),(\\d),(\\d)(,\\d+|{[\\dx,\\[\\]\\{\\}]+})?")
              re2 (RegExp. ",?(.+?,.+?,.+?,[\\d\\{}]+)")
              ch  []
              c   nil]
          (loop [c (re2.exec children)]
            (if (not (= c nil)) (do
              (ch.push (aget c 1))
              (recur (re2.exec children)))))
          ch))]

  (fn parse-layout-string [layout]
    (let [re   (RegExp. "(\\d+x\\d+),(\\d+),(\\d+)(,\\d+|{[\\dx,\\[\\]\\{\\}]+})")
          l    (re.exec layout)
          node { :width    (Number (aget (.split (aget l 1) "x") 0))
                 :height   (Number (aget (.split (aget l 1) "x") 1))
                 :offset   (Number (aget l 2))
                 :wtf      (Number (aget l 3))
                 :window   (or (Number (.slice (aget l 4) 1)) nil)
                 :split    nil
                 :children [] }]

        (if (is-na-n (Number (aget l 4)))
          (do
            (cond
              (= (aget (aget l 4) 0) "{") (set! node.split :vertical)
              (= (aget (aget l 4) 0) "[") (set! node.split :horizontal)
              :else (throw))
            (set! node.children
              (.map
                (split-children (.slice (aget l 4) 1 -1))
                parse-layout-string)))
          (set! node.window (Number (aget l 4))))

        node)))
