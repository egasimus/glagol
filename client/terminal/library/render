(fn [screen state]
  (let [bless (require "etude-bless")

        input (bless.Textbox {
          :top 0 :height 1 :left 0 :right 0
          :padding { :left 1 :right 1 }
          :fg (if (= :input state.focus) nil :white)
          :bg (if (= :input state.focus) :black nil)
          :value state.input })

        results (bless.Layout {
          :top 1 :left 0 :right 0 :bottom 1
          :renderer (fn column-renderer [coords]
            (let [top 0]
              (fn [el i]
                (set! el.shrink         true)
                (set! el.position.left  (or el.position.left  0))
                (set! el.position.right (or el.position.right 0))
                (set! el.position.top   top)
                (set! top (+ top el.height))))) })

        help (bless.Text {
          :bottom 0 :left 0 :right 0 :fg :white
          :content (aget ./help state.focus) })]

    (state.results.map (fn [result i]
      (let [bg  (if (and (= :results state.focus) (= i state.selected)) :black nil)
            box (bless.Box { :height 3 :bg bg })]
        (box.append (bless.Text {
          :left 1 :top 0 :height 1
          :content result.path :bg bg }))
        (results.append box))))

    (screen.children.map #(.destroy %1))

    (.map [input results help] #(screen.append %1))

    (screen.render)))
