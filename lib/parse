(let [split-children (fn [children]
        (let [re1 "/(\d+x\d+),(\d),(\d)(,\d+|{[\dx,\[\]\{\}]+})?/"
              re2 "/,?(.+?,.+?,.+?,[\d\{}]+)/g"
              ch  []
              c   nil]
          (loop [c (re2.exec children)]
            (if (not (= c nil)) (do
              (ch.push (aget c 1))
              (recur (re2.exec children)))))
          ch))]

  (fn parse [layout]
    (let [re   "/(\d+x\d+),(\d+),(\d+)(,\d+|{[\dx,\[\]\{\}]+})/"
          l    (re.exec layout)
          node { :width    (Number (aget (.split (aget l 1) "x") 0))
                 :height   (Number (aget (.split (aget l 1) "x") 1))
                 :offset   (Number (aget l 2))
                 :wtf      (Number (aget l 3))
                 :window   (or (Number (.slice (aget l 4) 1)) nil)
                 :split    nil
                 :children [] }]

      (if (is-nan (Number (aget l 4)))
        (do
          (cond
            (= (aget (aget l 4) 0) "{") (set! node.split :vertical)
            (= (aget (aget l 4) 0) "[") (set! node.split :horizontal)
            :else (throw))
          (set! node.children
            (.map
              (split-children (.slice (aget l 4) 1 -1))
              parse)))
        (set! node.window (Number (aget l 4))))

      node)))
