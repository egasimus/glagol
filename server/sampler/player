(fn player [options]
  (let [osc      ../osc/api
        osc-port (osc.get-next-port)
        osc-send (osc.bind-to osc-port)

        jack-client-name (or options.name options.sample :postmelodic)
        jack-port-name   (str jack-client-name ":output")

        jack             (require "etude-jack")
        jack-client      (jack.client jack-client-name)

        event2 (require "eventemitter2")
        state  (event2.EventEmitter2.) ]

    (osc.on "message" (fn [msg]
      (if (= (str osc-port) (aget msg.args 0)) (do
        (cond
          (= "/loaded"  msg.address) (state.emit "loaded"  msg.args)
          (= "/stopped" msg.address) (state.emit "stopped" msg.args)
          (= "/playing" msg.address) (state.emit "playing" msg.args))))))

    (jack-client.then (fn []
      (log "jack client ready"))
      (osc-send "/listen"))

    (set! state (merge state {
      :jack
        { :client  jack-client
          :started jack-client.started
          :port    jack-client.port }

      :osc
        { :port osc-port
          :send osc-send }

      :process
        (apply jack.spawn
          (.concat
            [ options.name
              ./options/player-path
              "-n" jack-client-name
              "-p" osc-port ]
            (if options.sample [options.sample] [])))

      :kill
        (fn [signal] (state.process.kill signal))
      :play
        (fn [cue]    (osc-send "/play" 0 (or cue 0)))
      :stop
        (fn []       (osc-send "/stop" 0))
      :load
        (fn [path]   (osc-send "/load" 0 path))
    }))

    state))
