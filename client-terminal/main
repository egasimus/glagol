(let [B
        (require "blessed")

      screen
        (B.screen { :smartCSR true :bg nil })


      add-clips
        (fn [parent x y n c]
          (loop [i 0]
            (let [top    (+ (* i 2) y)
                  text   { :bg c :fg :black :top (+ top 1) }
                  border { :inverse true :bg nil :fg c :left x }]
              (.map
                (.concat
                  (.map [ [ :content " ▶ "       :left x       :top (+ top 1) ]
                          [ :content "Clip 001 " :left (+ x 3) :top (+ top 1) ] ]
                    (fn [el] (apply assoc text el)))
                  (.map [ [ :content (./repeat 12 "▁") :top top :inverse true ]
                          [ :content (./repeat 12 "▅") :top (+ top 2)] ]
                    (fn [el] (apply assoc border el))))
                (fn [el] (parent.append (B.text el))))
              (if (< i (- n 1)) (recur (+ i 1)))))
          parent)

      add-scene
        (fn [parent y text]
          (let [w (- parent.width text.length 3)]
            (parent.append (B.text
              { :content (./repeat w "━") :top y :left (+ text.length 2) :fg :black }))
            (parent.append (B.text { :content text :left 1 :top y }))
            parent))

      calculate-scene-positions
        (fn [session]
          (let [coordinates {}
                next-y      3]
            (session.map (fn [scene]
              (let [most-clips 1]
                (scene.contents.map (fn [track i]
                  (if (and (= 0 (mod i 2)) (< most-clips track.length))
                    (set! most-clips track.length))))
                (aset coordinates next-y scene)
                (set! next-y (+ next-y (* most-clips 2))))))
            coordinates))

      draw-clip
        (fn [current i clip j clips]
          (let [x (+ 11 (* 13 (/ (./tracks/index-of current) 2)))]
            (add-clips screen x (+ 5 (* 3 i)) clips.length :red)))

      draw-track
        (fn [current i clips]
          (if clips (clips.map (draw-clip.bind nil current i))))

      get-y
        (fn [i] (+ 6 (* 3 i)))

      draw-scene
        (fn [scene i scenes]
          (add-scene screen (get-y i) (str i " " (aget scene 0)))
          (let [current-track nil
                current-scene (aget scene 1)]
            (if current-scene (current-scene.map (fn [track j]
              (if (= 0 (mod j 2))
                (set! current-track track)
                (draw-track current-track i track)))))))

      session-box
        (B.box { :top 3 :left 1 :right 1 :bottom 1 :scrollable true })

  ]

  ; setup
  (set! screen.title "etude demo")
  (screen.enable-mouse)

  ; keyboard events
  (.map (keys ./keymap) (fn [event]
    (screen.key (aget ./keymap event)
      (fn [c k] (./events/emit event [c k])))))
  (./events/on :exit (fn [] (process.exit)))
  (./events/on :refresh (fn [] (screen.realloc) (screen.render)))

  ; toolbars
  (./toolbar screen)
  (./statusbar screen)

  ; session body
  (screen.append session-box)
  (let [scenes (calculate-scene-positions ./session)]
    (.map (keys scenes) (fn [i]
      (let [scene (aget scenes i)]
        (add-scene session-box (Number i) scene.label)))))
  (./tracks/map (fn [track i] (if (= 0 (mod i 2)) (do
    (let [x (+ 12 (* (/ i 2) 13))]
      (session-box.append (B.text {
        :content (./repeat (+ 4 track.length) "▅")
        :bg nil :fg :black
        :top 0
        :left x}))
      (session-box.append (B.text {
        :content (str (/ i 2) " " track)
        :bg :black
        :padding { :left 1 :right 1 }
        :top 1
        :left x}))
      (add-clips session-box x 2 10 :black))))))

  (screen.render)

  { :undo (fn [] (screen.destroy)) })
