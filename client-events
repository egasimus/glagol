(let [emitter
        (new (.-EventEmitter2 (require "eventemitter2"))
          { :maxListeners 64 :wildcard true } )

      update
        (fn [k v] (set! ./client-state (assoc ./client-state k v)))

      replace
        (fn [array target new-value]
          (array.map (fn [old-value index]
            (if (= index target) new-value old-value))))]


  ;; jack backend switch
  (emitter.on "jack.init"
    (fn []
      (log "starting JACK backend...")
      (.then (.invoke (./client-api/get "api") "init")
        (fn [jack-state]
          (log "JACK started.")
          (update :jack jack-state)))))


  ;; react to transport events
  (emitter.on "transport.play"
    (fn []
      (log "pressing play...")
      (.then (.invoke (./client-api/get "api") "start")
        (fn []
          (log "playing, transport rolling.")
          (update :playing true)))))

  (emitter.on "transport.stop"
    (fn []
      (log "pressing stop...")
      (.then (.invoke (./client-api/get "api") "stop")
        (fn []
          (log "stopped, transport halted")
          (update :playing false)))))

  (emitter.on "transport.pulse"
    (fn [t]
      (update :position t)))


  ;; sequencer tracks
  (emitter.on "sequencer.track"
    (fn [args]
      (let [i (aget args 0) t (aget args 1)]
        (.then (t.get "name") (fn [n]
          (update :tracks (replace ./client-state/tracks i
            (assoc (aget ./client-state/tracks i)
              :name    n
              :loading false)))))
        (.then (t.get "data") (fn [d]
          (.then (d.get "selector") (fn [s]
            (log "-->" i s)
            (update :tracks (replace ./client-state/tracks i
              (assoc (aget ./client-state/tracks i) :data
                (assoc (aget (./client-state/tracks i) :data)
                  :selector s))))))
          (.then (d.get "selected") (fn [s]
            (log "-->" i s)
            (update :tracks (replace ./client-state/tracks i
              (assoc (aget ./client-state/tracks i) :data
                (assoc (aget (./client-state/tracks i) :data)
                  :selected s))))))
          (.then (d.get "slots")    (fn [s]
            (log "-->" i s)
            (update :tracks (replace ./client-state/tracks i
              (assoc (aget ./client-state/tracks i) :data
                (assoc (aget (./client-state/tracks i) :data)
                  :slots s)))))))))))
            ;(log "-->" i s))))))))

        ;(.then (.get "length" (t.get "data")) (fn [d]
          ;(log "-->" i d))))))
        ;(.then (t.get "name") (fn [n]
          ;(let [state ./client-state]
            ;(set! ./client-state (assoc state :tracks))))))))


  ;; sequencer editing
  (emitter.on "sequencer.click"
    (fn [t n]
      (log "clicked track" t "at" n)))


  ;; respond to midi control
  (let [on-fader
          (fn [t m1 track-num selector]
            (let [track   (aget ./client-state/tracks track-num)
                  data    (assoc track.data
                            :selector (/ selector 127)
                            :selected (Math.floor (/ selector 16)))
                  tracks  (replace ./client-state/tracks track-num
                            (assoc track :data data)) ]
              (update :tracks tracks)))
        on-knob
          (fn [t m1 m2 m3]
            (log "knob" (- m2 16)))]
    (emitter.on "control.nano" (fn [msg]
      (let [t  (aget msg 0)
            m1 (aget msg 1)
            m2 (aget msg 2)
            m3 (aget msg 3)]
        (if (= m1 189)
          ((cond
            (< m2 8)                  on-fader
            (and (> m2 15) (< m2 24)) on-knob
            ) t m1 m2 m3))))))

  emitter)
